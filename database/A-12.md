## 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?

- Scale Up: 데이터베이스의 리소스 업그레이드하여서 컴퓨터 성능을 끌어올린다. 
- Scale Out: 데이터베이스 서버를 여러 곳으로 분산하거나 여러 서버가 공유 데이터를 가지도록 한다. 그러나 이 방식은 쿼리 처리와 data consistency에 복잡성이 커질 수 있다. 
- Data Caching: Redis나 Memcached를 사용하여서 인메모리에 데이터를 두어서 접근 속도를 높일 수 있다. 

### DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?
- 쿼리 최적화: 쿼리를 분석하여서 불필요한 처리를 최소화하고 효율적으로 쿼리를 작성할 수 있도록 한다. 
	- **인덱싱**: 인덱스를 통해 특정 칼럼이나 필드 기반으로 데이터 검색 속도를 높여서 쿼리 속도를 최적화한다. 
	- **쿼리 재작성**: 같은 결과를 내는 쿼리를 재작성하여서 효율적인 실행이 작동하도록 한다. 
	- **쿼리 캐싱**: 한번 실행한 쿼리를 재활용하여서 쿼리 중복을 낮추어 쿼리 응답 시간을 낮춘다.
		추가 설명:
		- SQL 실행결과를 메모리에 저장해 두어 같은 쿼리가 들어오면 메모리에서 결과 값을 사용할 수 있게 하는 방법 
		- MySQL 5.7버전 이후로 deprecated 되었다. 
		- 대안으로 인메모리디비를 사용할 수 있다. 
	- **쿼리 병렬처리 (Query parallelization)**: 분산 시스템에 있는 노드에 워크로도를 분산처리하여서 쿼리 퍼포먼스를 높인다. 
- Connection Pooling: 기존 디비 커넥션을 재사용하여서 디비 연결 비용 줄이기. 
	- 드라이버나 커넥션 풀 라이브러로 미리 데이터베이스와 어플리케이션 서버 사이 연결을 걸어둠. 
	- pool에 담긴 커넥션 가운데 사용하지 않는 커넥션을 사용해서 디비와 통신한다. 
	- 커넥션을 관리하며 완전히 사용하지 않는 상태일 때 연결을 끊는다. 
	- 연결 비용이 들지 않고, 바로 사용가능하기 때문에 레이턴시를 줄여서 더 빠른 응답을 이끌어 낼 수 있다. -> 더 많은 요청을 처리할 수 있다. 
	
- 정규화: 정규화로 반복되는 데이터 및 오퍼레이션을 줄이기. 
- 비정규화: 과도한 join으로 쿼리 처리 속도에 악영향이 있을 경우 의도적으로 비정규화를 할 수 있다. 


# 참조
- https://www.liquidweb.com/blog/horizontal-vs-vertical-scaling/#:~:text=There%20is%20a%20limit%20to,in%20terms%20of%20cost%20performance.
- [참조](https://youtu.be/zowzVqx3MQ4?si=2RO3lrWna8jLKN3k)