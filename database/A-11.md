# DB Locking
- Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
# Pessimistic Locking
- 충돌이 일어난다고 가정하여 
- 데이터 읽거나 변형 전에 락 걸어버림 
- 데이터 경합이 많은 환경에서 데이터 업데이트가 확실히 보장된 환경에서 써야 한다. 

# Optimistic Locking
- Pessimistic보다 관대하다
- 충돌이 거의 일어나지 않을 것이라고 가정
- 버전 관리를 통해서 Lost Update가 생기지 않도록 방지한다. 
- 데이터 경합보다 많이 읽는 환경에서 쓰기 좋음
- version 칼럼이 필요하다. UPDATE or DELETE가 발생하며 버전이 업그레이드 된다. 
- 읽기 작업을 통해 특정 버전 값을 알게되고, 값을 갱신할 때도 특정 버전 값을 갱신 요청을 보낸다. 
    - 특정 버전의 값이 이미 업데이트되었다면, 버전이 맞지 않아서 수정할 수 없다. 즉, 이 트랜잭션이 무효가 되고, lost update 문제를 에방할 수 있다. 

### Pessimistic Locking과 Optimistic Locking이 필요한 이유: Lost Update란? 
A와 B가 50만원가 든 계좌에서 각각 30만원, 40만원 동시에 이체한다고 가정하자. A와 B 둘 다 계좌에 50만원이 있다고 판단하였기 때문에 트랜젝션이 수행되었다. 
그러나 실제로 연속적으로 트렌젝션이 일어나기 때문에 50 -> 20 -> -20 만원 순으로 계산된다. 그러나 계좌는 음수가 될 수 없고, 예상한 결과를 얻는 것도 아니다. 
이처럼 같은 레코드에 서로 다른 트랜젝션이 동시에 일어날 때, lost update가 발생할 수 있다. 
이를 예방하기 위해서 Pessimistic locking과 Optimistic Locking 두 가지 전략이 존재한다. 


### DB Locking은 여러 유저가 사용하는 환경에서 데이터의 일관성을 유지하기 위해 필요

#### Locking 레벨 
- Database Level: 데이터 베이스 전체를 한 유저만 사용
- Table Level: 전체 테이블을 읽거나 쓰는 것을 막을 수 있음
- Page/Block Level: 테이블의 특정 부분을 제한 
- Row Level
- Column Level: row의 특정 부분 제한

#### Lock Type:
- Shared Lock: 다양한 트랜젝션을 데이터를 읽을 수 있으나 쓰는 것은 한 명이 한 번 씩만
- Exclusive Lock: 오직 한 유저만 쓰거나 읽을 수 있음

## 선택지
1. 데이터 경합이 많은 환경 -> Pessimistic Locking
2. 읽기 많고, 업데이터 덜한 환경 -> Optimistic Locking


#  물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

1. 자동 해제: RDBMS에서 제공하는 Timeout으로 Lock 유지 되는 시간 조정되어 자동으로 Lock 해제
2. Deadlock Detection: 데드락이 발생할 경우 알고리즘에 의해서 덜 중요한 Lock 부터 없어짐
3. 2-Phase Locking: Lock을 얻고 해제하는 과정. 모든 락이 얻어야 수정 가능 
4. Lock Manager: 중앙에서 관리하는 Lock Manager 존재
5. Transaction Logging: 모든 데이터 변경 사항 저장하여서 종료되더라도 Log를 통해서 복구하여 Lock 해제

# 참고 
- https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking
