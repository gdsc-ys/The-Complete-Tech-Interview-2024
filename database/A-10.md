
## B-Tree와 B+Tree에 대해 설명해 주세요.

#### B Tree
	 B Tree란?
	 BST에서 자녀 노드의 개수를 일반화한 트리 
	 부모 노드의 값에 따라서 분기하는 자녀 노드의 수가 달라질 수 있다. 
[영상출처](https://youtu.be/bqkcoSm_rCs?si=-OcozLfZ_Jtwg5B4)

#### 주요한 파라미터
M: 각 노의 최대 자녀 노드 수 
M-1: 각 노드의 최대 key 수 
\[M/2\]: 각 노드의 최소 자녀 노드 수 (root node, leaf node 제외)\]
\[M/2\]-1: 각 노드의 최소 key 수 (root node 제외)

#### B tree 데이터 삽입 
- 노드가 넘치면 가운데 key를 기준으로 좌우 key들을 분할하고 가운데 key는 승진한다.
- 승진은 항상 leaf node에 추가한다 

#### 다른 AVL tree(self-balancing BST)에 비해 장점
- 데이터 찾을 때 탐색 범위를 빠르게 좁힐 수 있음 (자식 노드의 개수를 2개 이상으로 설정가능) 
- storage 접근 회수가 더 짧음 
- block를 읽어오면서 저장 공간 활용도가 높다. (정렬된 자식노드)

![[Pasted image 20240331231256.png]]
[참조](https://stackoverflow.com/questions/870218/what-are-the-differences-between-b-trees-and-b-trees)

#### B-Tree 특징 
- internal node도 데이터 포인터가 있다
- 데이터 full-scan하기 위해서 모두 순회해야 하기 때문에 비용(시간)이 많이 든다

#### B+Tree 특징
- leaf node에 각 데이터 포인터가 존재한다
- internal node는 데이터 포인터 없기 때문에 한 메모리 페이지에 더 많이 담을 수 있다. (불필요하게 데이터 가질 필요없기 때문이다) -> 캐시 히트가 높아진다 
- leaf node에서 데이터끼리 linear하게 연결되어 있기 때문에 full-scan하기 용이하다 
- B-Tree에 비해서 full-scan 비용이 낮다


### 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?

- b-Tree는 internal Node에 데이터 포인터가 없기 때문에 일부 케이스에서 접근 횟수를 줄일 수 있여서 더 빨리 접근할 기회가 없다. 

### DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?
- 캐시 히트 때문이다
- 블락 단위로 캐시 작업이 이뤄지는데. B Tree는 key value이 정렬되어서 하나 블록에 모여 있기 때문에 접근 횟수를 줄일 수 있다. -> 전체 퍼포먼스 향상 (디스크 접근 시간 줄이기) 


### 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.
- B+tree는 거꾸로 접근하여서 순차적으로 접근하지만 
- B-tree는 모든 노드를 순회하면서 내림차순으로 정렬한다. 

[참조](https://tech.kakao.com/2018/06/19/mysql-ascending-index-vs-descending-index/)
